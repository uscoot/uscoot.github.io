<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【设计模式笔记】01、设计模式简介]]></title>
    <url>%2FDesignPattern-001%2F</url>
    <content type="text"><![CDATA[什么是模式模式是指从某个具体的形式中得到的一种抽象，在特殊的非任意性的环境中，该形式不断地重复出现。 模式≠某个问题的答案 模式所描述的问题及答案都应有代表性 以不同的形式重复出现 允许应用到不同的环境中去 什么是软件设计模式1) 关注在特定设计环境中重复出现的设计问题，并为它提供一个解决方案MVC模式关注问题——支持用户界面的可变性。解决方案——严格区分职责，将应用程序的核心功 能从其用户界面中分离出来。 2) 是用文档记录下来的设计经验，来重用设计知识这种设计经验是现已存在的、经过充分考验的、不是人工发明或创造的。 3) 是类和实例层次（或组件层次）之上的抽象一个模式描述几个组件、类或对象，并详细说明它们的职责和关系以及它们之间的合作。所有组件共同解决模式关注的问题，而且通常比单个组件更有效。例如，MVC模式描述了三个合作组件的三元组，每个 MVC三元组也同系统的其他的MVC三元组合作。 4) 提供一种设计原则的公共词汇和理解模式名称是对问题及方案需求的简洁描述。例如， MVC 在20世纪80年代就被有关团体熟悉。 5) 提供设计软件系统时的基本构想（Vision）MVC模式基本构想：使核心功能与用户输入和信息显示分离。 6) 描述一种处理所关注问题的可行方法，有助于管理软件复杂度包括： ● 所需组件的种类 ● 它们的作用 ● 要隐藏的细节 ● 应为可视化的抽象 ● 各要素如何工作 7) 模式提供一个功能行为的基本框架属性——软件系统的非功能需求可更改性、可靠性、可测试性、可重用性；有的模式用于维护合作组件之间的一致性；有的模式提供透明对等的进程间通信；例如：MVC模式支持用户界面的可更改性和核心功能的可重用性。 8) 提供建立一个复杂软件体系结构组件、作用及相互关系的预定义集有助于选择和评估方案。提高设计速度和质量。但模式只确定解决设计问题的基本结构，即一般图式（ Schema），不给出完整的可使用的预制模式。 模式的四个基本要素 模式名称 问题 解决方案 末态环境后果 模式中常用图例说明● 图片中的空心三角箭头，代表着继承（extends）或实现（Implement）关系， 由继承者/实现者 指向 被继承者/被继承者。● 图片中的实心三角箭头且箭头末尾没有圆圈的， 代表着单一的引用关系， 但是被引用的对象也有可能被其他对象引用。● 图片中的实心三角箭头且箭头末尾有圆圈的， 代表着一对多的引用关系。● 图片中的末端有圆圈的虚线是一个对方法体内容用伪代码说明的关系。 公认的软件设计原则目标：构建松散耦合的系统。Spring就是按照这些设计原则进行设计的，所以如果能把这些原则理解透彻，我们就能非常自如的使用Spring来构建可靠稳定健壮的系统。 1) 开-闭原则(Open-Closed Principle, OCP)一个软件实体应当对扩展开发，对修改关闭。说的是在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。换言之，应当可以在不必修改源代码的情况下改变这个模块的行为，在保持系统一定稳定性的基础上，对系统进行扩展。这是面向对象设计（OOD）的基石，也是最重要的原则。 重点： 不修改源代码前提下进行系统功能扩展或更新 如果直接修改源代码，之前的测试就废了，需要重新测试 所以通过增加代码的方式扩展系统功能更可靠 Spring的体现：新建一个类注册后直接装配这个新的Bean 举例：玉帝招安美猴王之法 不允许更改系统的抽象层 —— 现有的天庭秩序 允许扩展实现层 —— 弻马温 2) 里氏代换原则(Liskov Substitution Principle, LSP)表述1：如果对每一个类型为T1的对象O1，都有类型为T2的对象O2。使得以T1定义的所有程序P在所有的对象O1都代换成O2时，程序P的行为没有变化，那么类型T2是类型T1的子类型。表述2：一个软件实体如果适用一个基类对象，那么一定适用于其子类对象。表述3：使用指向基类的指针或引用的函数，必须能够在不知道具体派生类对象类型的情况下使用它们。 PS：子类必须具备基类的全部接口；子类必须包括比基类型更宽的接口 重点： 里氏代换原则是继承复用的基石，是对“开—闭”原则的补充，是对实现抽象化的具体步骤的规范，里氏代换原则是开—闭原则的必要条件。 一般而言，违反里氏代换原则的，也违背“开—闭”原则，反过来不一定成立。 只有当衍生类可以替换掉基类，软件单位的功能不会受到影响时，基类才能真正被复用。而衍生类也才能够在基类的基础上增加新的行为。 举例：假设有两个类： Base 类，Derived类，且 Derived 类是 Base类的子类。一个方法如果可以接受一个基类对象 b 的话： method (b)，那么它必然可以接受一个子类对象 d ，也可以有method (d)。反过来的代换不成立，即如果一个软件实体使用的是一个子类的话，那么它不一定适用于基类。 3) 依赖倒置原则(Dependence Inversion Principle)● 优点：不必知道对象的类型，只要对象遵守接口。不必知道对象的类，只需知道定义接口的抽象类。降低了子系统间的实现依赖。 依赖倒转关系强调了系统内的实体之间关系的灵话性，从具体耦合变为抽象耦合。 ● 不容易实现：创建对象要避免对具体类的直接引用，有时需要创建抽象类。会导致大量的类，维护难度大。倒转原则假定所有的具体类都是会变化的，不排除有一些具体类相当稳定。 PS：面向接口编程，系统模块化 重点： 抽象不应当依赖于细节，细节应当依赖于抽象 依赖于接口，不要依赖于实现 PS：与“开—闭”原则的关系“开一闭”原则是目标，依赖倒转原则是达到这一目标的手段。换言之，要想实现“开—闭”原则，就应当坚持依赖倒转原则。违反依赖倒转原则，就不可能达到“开—闭”原则的要求。 4) 接口隔离原则(Interface Segregation Principle, ISP)面向对象的设计的一个重要内容：准确而恰当地划分角色以及角色所对应的接口。 “接口”：一个类所提供的所有方法的特征集合的逻辑概念。 (1) 接口的划分直接影响类型的划分 (2) 接口→剧本中的角色 (3) 接口实现→相当于演员 (4) 接口隔离原则＝角色隔离原则：每一个角色都应当由一个特定的接口代表 重点： 一个类对另一个类的依赖性应当建立在最小的接口上 使用多个专门的接口比使用单个的总接口要好 为同一个角色不同的客户端，提供宽、窄不同的接口，叫做定制服务 PS：接口污染：过于臃肿的接口一个没有经验的设计师往往想节省接口的数目，将差不多的接口合并， 认为是代码优化，这是错误的。将没有关系的接口合并在一起，是对角色和接口的污染。 5) 合成/聚合复用原则(Composite/Aggregate Reuse Principle,CARP)尽量使用合成 /聚合而不是继承来达到对实现的复用，即使用聚合/组合 代替 继承。 重点： 使用已有对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。 一个角色如果有更多的责任，那么可以使用合成/聚合关系将新的责任委派到合适的对象。 可以将已有的对象纳入到新对象中，成为新对象的一部分，新的对象可以调用已有对象的功能。 新对象存取成分对象的唯一方法是通过成分对象的接口。 PS：缺点：需要管理较多的对象。 6) 迪米特法则(Law of Demeter LoD)迪米特法则又称最少知识原则，最初是用来作为面向对象的系统设计风格的一种法则， 1987 年由 L . Holland 在美国东北大学Demeter 项目设计提出的，因此叫做迪米特法则 。是很多著名系统．比如火星登录软件系统、木星的欧罗巴卫星轨道飞船的软件系统的指导设计原则。 一个对象应当对其他对象有尽可能少的了解。 重点： 只与你直接的朋友们通信 不要跟“陌生人”说话 每一个软件单元对其他的单元都只有最少的知识，而且局限于那些与本单位密切相关的软件单位 举例： 7) 单一职责原则(Simple responsibility pinciple SRP)就一个类而言，应该仅有一个引起它变化的原因，如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。应该把多于的指责分离出去，分别再创建一些类来完成每一个职责。 系统的每个对象应该将重点放在问题域中的离散抽象上。因此理想的情况下，一个对象只做一件事情。这样在开发中也就带来了诸多的好处：提供了重用性和维护性，也是进行重构的良好的基础。 总结设计模式的基础和前提是你的程序尽可能遵循以上原则。]]></content>
      <categories>
        <category>设计模式笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>软件设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JAVA8笔记】07、新时间和日期]]></title>
    <url>%2FJAVA8-007%2F</url>
    <content type="text"><![CDATA[传统时间格式化的线程安全问题传统时间(非线程安全的)12345678910111213141516SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");Callable&lt;Date&gt; task = new Callable&lt;Date&gt;() &#123; @Override public Date call() throws Exception &#123; return sdf.parse("20161121"); &#125;&#125;;ExecutorService pool = Executors.newFixedThreadPool(50);List&lt;Future&lt;Date&gt;&gt; results = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 100; i++) &#123; results.add(pool.submit(task));&#125;for (Future&lt;Date&gt; future : results) &#123; System.out.println(future.get());&#125;pool.shutdown(); Exception in thread “main” java.util.concurrent.ExecutionException: java.lang.NumberFormatException: For input string: “” at java.util.concurrent.FutureTask.report(FutureTask.java:122) at java.util.concurrent.FutureTask.get(FutureTask.java:192) 传统解决办法(加锁)12345678910111213public class DateFormatThreadLocal &#123; private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;()&#123; protected DateFormat initialValue()&#123; return new SimpleDateFormat("yyyyMMdd"); &#125; &#125;; public static final Date convert(String source) throws ParseException&#123; return df.get().parse(source); &#125;&#125; 123456789101112131415Callable&lt;Date&gt; task = new Callable&lt;Date&gt;() &#123; @Override public Date call() throws Exception &#123; return DateFormatThreadLocal.convert("20161121"); &#125;&#125;;ExecutorService pool = Executors.newFixedThreadPool(10);List&lt;Future&lt;Date&gt;&gt; results = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; results.add(pool.submit(task));&#125;for (Future&lt;Date&gt; future : results) &#123; System.out.println(future.get());&#125;pool.shutdown(); Mon Nov 21 00:00:00 CST 2016Mon Nov 21 00:00:00 CST 2016Mon Nov 21 00:00:00 CST 2016Mon Nov 21 00:00:00 CST 2016… Java8时间(线程安全的)因为不管做什么改变它都产生新的实例，所以是线程安全的 123456789101112131415161718DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyyMMdd");Callable&lt;LocalDate&gt; task = new Callable&lt;LocalDate&gt;() &#123; @Override public LocalDate call() throws Exception &#123; LocalDate ld = LocalDate.parse("20161121", dtf); return ld; &#125;&#125;;ExecutorService pool = Executors.newFixedThreadPool(10);List&lt;Future&lt;LocalDate&gt;&gt; results = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; results.add(pool.submit(task));&#125;for (Future&lt;LocalDate&gt; future : results) &#123; System.out.println(future.get());&#125;pool.shutdown(); 2016-11-212016-11-212016-11-212016-11-21… 本地时间与时间戳LocalDate、LocalTime、LocalDateTimeLocalDate、LocalTime、LocalDateTime 类的实例是不可变的对象，分别表示使用ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。● now() ：静态方法，根据当前时间创建对象● of() ：静态方法，根据指定日期/时间创建对象● plusDays, plusWeeks, plusMonths, plusYears ：向当前LocalDate对象添加几天、几周、几个月、几年● minusDays, minusWeeks, minusMonths, minusYears ：从当前LocalDate对象减去几天、几周、几个月、几年● plus, minus ：添加或减少一个Duration或Period● withDayOfMonth, withDayOfYear, withMonth, withYear ：将月份天数、年份天数、月份、年份修改为指定的值并返回新的LocalDate对象● getDayOfMonth ：获得月份天数(1-31)● getDayOfYear ：获得年份天数(1-366)● getDayOfWeek ：获得星期几(返回一个DayOfWeek枚举值)● getMonth ：获得月份,返回一个Month枚举值● getMonthValue ：获得月份(1-12)● getYear ：获得年份● until ：获得两个日期之间的Period对象，或者指定ChronoUnits的数字● isBefore, isAfter ：比较两个LocalDate● isLeapYear ：判断是否是闰年 示例：123456789101112131415161718LocalDateTime ldt = LocalDateTime.now();System.out.println(ldt);LocalDateTime ld2 = LocalDateTime.of(2016, 11, 21, 10, 10, 10);System.out.println(ld2);LocalDateTime ldt3 = ld2.plusYears(20);System.out.println(ldt3);LocalDateTime ldt4 = ld2.minusMonths(2);System.out.println(ldt4);System.out.println(ldt.getYear());System.out.println(ldt.getMonthValue());System.out.println(ldt.getDayOfMonth());System.out.println(ldt.getHour());System.out.println(ldt.getMinute());System.out.println(ldt.getSecond()); 2017-10-19T12:10:06.9622016-11-21T10:10:102036-11-21T10:10:102016-09-21T10:10:102017101912106 Instant 时间戳用于“时间戳”的运算，它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的毫秒数进行运算。PS：默认使用 UTC 时区。 示例：1234567891011Instant ins1 = Instant.now(); Thread.sleep(1000);Instant ins2 = Instant.now();System.out.println("Cost time：" + Duration.between(ins1, ins2));LocalDate ld1 = LocalDate.now();LocalDate ld2 = LocalDate.of(2011, 1, 1);Period pe = Period.between(ld2, ld1);System.out.println(pe.getYears());System.out.println(pe.getMonths());System.out.println(pe.getDays()); 2017-10-19T04:14:31.701Z2017-10-19T12:14:31.701+08:007010000001970-01-01T00:00:05Z Duration 和 PeriodDuration: 用于计算两个“时间”间隔Period: 用于计算两个“日期”间隔 示例：1234567891011Instant ins1 = Instant.now(); Thread.sleep(1000);Instant ins2 = Instant.now();System.out.println("Cost time：" + Duration.between(ins1, ins2));LocalDate ld1 = LocalDate.now();LocalDate ld2 = LocalDate.of(2011, 1, 1);Period pe = Period.between(ld2, ld1);System.out.println(pe.getYears());System.out.println(pe.getMonths());System.out.println(pe.getDays()); Cost time：PT1S6918 时间校正器(TemporalAdjuster)将日期调整到“下个周日”TemporalAdjusters : 该类通过静态方法提供了大量的常用TemporalAdjuster 的实现。 1LocalDate nextSunday = LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.SUNDAY)); 自定义时间校正器123456789101112131415161718192021LocalDateTime ldt = LocalDateTime.now();System.out.println(ldt);LocalDateTime ldt2 = ldt.withDayOfMonth(10);System.out.println(ldt2);//Next WorkingDayLocalDateTime ldt5 = ldt.with((l) -&gt; &#123; LocalDateTime ldt4 = (LocalDateTime) l; DayOfWeek dow = ldt4.getDayOfWeek(); if(dow.equals(DayOfWeek.FRIDAY))&#123; return ldt4.plusDays(3); &#125;else if(dow.equals(DayOfWeek.SATURDAY))&#123; return ldt4.plusDays(2); &#125;else&#123; return ldt4.plusDays(1); &#125;&#125;);System.out.println(ldt5); 2017-10-19T12:24:30.9682017-10-10T12:24:30.9682017-10-20T12:24:30.968 时间格式化与时区的处理解析与格式化java.time.format.DateTimeFormatter 类，该类提供了三种格式化方法：1、预定义的标准格式2、语言环境相关的格式3、自定义的格式 12345678//DateTimeFormatter dtf = DateTimeFormatter.ISO_LOCAL_DATE;DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss E");LocalDateTime ldt = LocalDateTime.now();String strDate = ldt.format(dtf);System.out.println(strDate);LocalDateTime newLdt = ldt.parse(strDate, dtf);System.out.println(newLdt); 2017年10月19日 14:02:02 星期四2017-10-19T14:02:02 时区的处理Java8 中加入了对时区的支持，带时区的时间为分别为：ZonedDate、ZonedTime、ZonedDateTime其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如：Asia/Shanghai 等 ZoneId：该类中包含了所有的时区信息getAvailableZoneIds() : 可以获取所有时区时区信息of(id) : 用指定的时区信息获取ZoneId 对象 12345678Set&lt;String&gt; set = ZoneId.getAvailableZoneIds();//set.forEach(System.out::println);LocalDateTime ldt = LocalDateTime.now(ZoneId.of("Asia/Shanghai"));System.out.println(ldt);ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of("US/Pacific"));System.out.println(zdt); 2017-10-19T14:03:36.3632017-10-18T23:03:36.381-07:00[US/Pacific] 与传统日期处理的转换 类 实例 java.time.Instant — java.util.Date Date.from(instant) — date.toInstant() java.time.Instant — java.sql.Timestamp Timestamp.from(instant) — timestamp.toInstant() java.time.ZonedDateTime — java.util.GregorianCalendar GregorianCalendar.from(zonedDateTime) — cal.toZonedDateTime() java.time.LocalDate — java.sql.Time Date.valueOf(localDate) — date.toLocalDate() java.time.LocalTime — java.sql.Time Date.valueOf(localDate) — date.toLocalTime() java.time.LocalDateTime — java.sql.Timestamp Timestamp.valueOf(localDateTime) — timestamp.toLocalDateTime() java.time.ZoneId — java.util.TimeZone Timezone.getTimeZone(id) — timeZone.toZoneId() java.time.format.DateTimeFormatter — java.text.DateFormat 无 总结Java8中的新时间和日期明显更加强大]]></content>
      <categories>
        <category>JAVA8笔记</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JAVA8笔记】06、Optional容器类]]></title>
    <url>%2FJAVA8-006%2F</url>
    <content type="text"><![CDATA[Optional类简介Optional 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念，并且可以避免空指针异常。 Optional类方法Optional.of(T t)创建一个 Optional 实例 123Optional&lt;Employee&gt; op = Optional.of(new Employee());Employee emp = op.get();System.out.println(emp); Employee [id=0, name=null, age=0, salary=0.0, status=null] Optional.empty()创建一个空的 Optional 实例 12Optional&lt;Employee&gt; op = Optional.empty();System.out.println(op.get()); ERROR： java.util.NoSuchElementException: No value present at java.util.Optional.get(Optional.java:135) Optional.ofNullable(T t)若 t 不为null，创建 Optional 实例，否则创建空实例 12Optional&lt;Employee&gt; op = Optional.ofNullable(null);System.out.println(op.get()); ERROR： java.util.NoSuchElementException: No value present at java.util.Optional.get(Optional.java:135) isPresent()判断是否包含值 1234567Optional&lt;Employee&gt; op = Optional.ofNullable(null);//Optional&lt;Employee&gt; op = Optional.ofNullable(new Employee());if(op.isPresent())&#123; System.out.println(op.get());&#125;else&#123; System.out.println("NULL");&#125; NULL// Employee [id=0, name=null, age=0, salary=0.0, status=null] orElse(T t)如果调用对象包含值，返回该值，否则返回 t 123Optional&lt;Employee&gt; op = Optional.ofNullable(null);Employee emp = op.orElse(new Employee("张三"));System.out.println(emp); Employee [id=0, name=张三, age=0, salary=0.0, status=null] orElseGet(Supplier s)如果调用对象包含值，返回该值，否则返回 s 获取的值 123Optional&lt;Employee&gt; op = Optional.ofNullable(null);Employee emp2 = op.orElseGet(() -&gt; new Employee());System.out.println(emp2); Employee [id=0, name=null, age=0, salary=0.0, status=null] map(Function f)如果有值对其处理，并返回处理后的 Optional，否则返回 Optional.empty() 123Optional&lt;Employee&gt; op = Optional.of(new Employee(101, "张三", 18, 9999.99));Optional&lt;String&gt; op2 = op.map(Employee::getName);System.out.println(op2.get()); 张三 flatMap(Function mapper)与 map 类似，要求返回值必须是 Optional 123Optional&lt;Employee&gt; op = Optional.of(new Employee(101, "张三", 18, 9999.99));Optional&lt;String&gt; op3 = op.flatMap((e) -&gt; Optional.of(e.getName()));System.out.println(op3.get()); 张三 需求：获取一个男人心中女神的名字普通实现女神类123456789101112131415161718192021public class Godness &#123; private String name; public Godness() &#123;&#125; public Godness(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "Godness [name=" + name + "]"; &#125;&#125; 男人类123456789101112131415161718192021public class Man &#123; private Godness god; public Man() &#123;&#125; public Man(Godness god) &#123; this.god = god; &#125; public Godness getGod() &#123; return god; &#125; public void setGod(Godness god) &#123; this.god = god; &#125; @Override public String toString() &#123; return "Man [god=" + god + "]"; &#125;&#125; 测试PS：需要做嵌套的if判断才能避免空指针异常 12345678910public String getGodnessName(Man man)&#123; if(man != null)&#123; Godness g = man.getGod(); if(g != null)&#123; return g.getName(); &#125; &#125; return "仓老师";&#125; 123456@Testpublic void test5()&#123; Man man = new Man(); String name = getGodnessName(man); System.out.println(name);&#125; Optional实现新男人类123456789101112131415161718192021222324252627282930import java.util.Optional;//注意：Optional 不能被序列化public class NewMan &#123; private Optional&lt;Godness&gt; godness = Optional.empty(); private Godness god; public Optional&lt;Godness&gt; getGod()&#123; return Optional.of(god); &#125; public NewMan() &#123; &#125; public NewMan(Optional&lt;Godness&gt; godness) &#123; this.godness = godness; &#125; public Optional&lt;Godness&gt; getGodness() &#123; return godness; &#125; public void setGodness(Optional&lt;Godness&gt; godness) &#123; this.godness = godness; &#125; @Override public String toString() &#123; return "NewMan [godness=" + godness + "]"; &#125;&#125; 再测试PS：直接一句代码就能避免空指针，代码更简洁 123456public String getGodnessName2(Optional&lt;NewMan&gt; man)&#123; return man.orElse(new NewMan()) .getGodness() .orElse(new Godness("仓老师")) .getName();&#125; 1234567@Testpublic void test6()&#123; Optional&lt;Godness&gt; godness = Optional.ofNullable(new Godness("林志玲")); Optional&lt;NewMan&gt; op = Optional.ofNullable(new NewMan(godness)); String name = getGodnessName2(op); System.out.println(name);&#125; 总结Optional 类使用好能有效降低 NullPointerException]]></content>
      <categories>
        <category>JAVA8笔记</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Optional</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JAVA8笔记】05、Stream API]]></title>
    <url>%2FJAVA8-005%2F</url>
    <content type="text"><![CDATA[了解StreamJava8中有两大最为重要的改变：第一个是Lambda 表达式；另外一个则是Stream API(java.util.stream.*)。 Stream 是Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用SQL 执行的数据库查询。也可以使用Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。 什么是Stream“A sequence of elements supporting sequential and parallel aggregate operations.”● 是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列● 集合讲的是数据，流讲的是计算 注意： 1) Stream 自己不会存储元素。 2) Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 3) Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 Stream操作步骤 创建Stream一个数据源（如：集合、数组），获取一个流 1) 通过Collection系列集合提供的 stream() 或 parallelStream()12List&lt;String&gt; list = new ArrayList&lt;&gt;();Stream&lt;String&gt; stream1 = list.stream(); 2) 通过Arrays中的静态方法 stream() 获取数组流12Employee[] emps = new Employee[10];Stream&lt;Employee&gt; stream2 = Arrays.stream(emps); 3) 通过Stream类中的静态方法 of()1Stream&lt;String&gt; stream3 = Stream.of("aa", "bb", "cc"); 4) 创建无限流迭代：12Stream&lt;Integer&gt; stream4 = Stream.iterate(0, (x) -&gt; x + 2);stream4.limit(10).forEach(System.out::println); 生成：12Stream&lt;Double&gt; stream5 = Stream.generate(()-&gt;Math.random());stream5.limit(5).forEach(System.out::println); 中间操作一个中间操作链，对数据源的数据进行处理 ● 筛选与切片1) filter：对于Stream中包含的元素使用给定的过滤函数进行过滤操作，得到新的Stream ↓ 内部迭代：迭代操作由 Stream API 完成12345678910public void test02()&#123; //中间操作：不会执行任何操作 Stream&lt;Employee&gt; stream = emps.stream() .filter((e)-&gt;&#123; System.out.println("Stream API 的中间操作"); return e.getAge() &gt; 35; &#125;); //终止操作：一次性执行全部内容，即“惰性求值” stream.forEach(System.out::println);&#125; ↓ 外部迭代：123456public void test03()&#123; Iterator&lt;Employee&gt; it = emps.iterator(); while (it.hasNext())&#123; System.out.println(it.next()); &#125;&#125; 2) limit：对一个Stream进行截断操作，获取其前N个元素，得到新的Stream ↓ 只会迭代到找到符合条件的两条记录：1234567public void test04()&#123; emps.stream() .filter((e)-&gt;&#123; System.out.println("短路"); // &amp;&amp; || return e.getSalary() &gt; 5000; &#125;).limit(2).forEach(System.out::println);&#125; 3) skip：跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流 12345public void test05()&#123; emps.stream() .filter((e)-&gt;e.getSalary() &gt; 5000) .skip(2).forEach(System.out::println);&#125; 4) distinct：筛选，通过流所生成元素的hashCode() 和 equals() 去除重复元素 ↓ distinct需要重写hashCode和equals方法：12345public void test06()&#123; emps.stream() .filter((e)-&gt;e.getSalary() &gt; 5000) .skip(2).distinct().forEach(System.out::println);&#125; ● 映射与排序1) map：接收Lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素 1234567public static Stream&lt;Character&gt; filterCharacter(String str)&#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (Character ch : str.toCharArray()) &#123; list.add(ch); &#125; return list.stream();&#125; 1234567891011List&lt;String&gt; strList = Arrays.asList("aaa", "bbb", "ccc", "ddd", "eee");strList.stream().map(String::toUpperCase).forEach(System.out::println);System.out.println("-------------------------------------------");emps.stream().map(Employee::getName).forEach(System.out::println);System.out.println("-------------------------------------------");Stream&lt;Stream&lt;Character&gt;&gt; stream2 = strList.stream().map(TestStreamAPI1::filterCharacter);stream2.forEach((sm) -&gt; &#123; sm.forEach(System.out::println);&#125;); 2) flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 123456789Stream&lt;Stream&lt;Character&gt;&gt; stream3 = strList.stream().map(TestStreamAPI1::filterCharacter); stream3.forEach((sm)-&gt;&#123; sm.forEach(System.out::println); &#125;);&#125;);System.out.println("---------------------------------------------");Stream&lt;Character&gt; stream4 = strList.stream().flatMap(TestStreamAPI1::filterCharacter);stream4.forEach(System.out::println); 3) sorted：sorted(): 自然排序(Comparable) 、 sorted(Comparator com): 定制排序(Comparator) 123456789101112131415public void test6()&#123; emps.stream() .map(Employee::getName) .sorted() .forEach(System.out::println); System.out.println("------------------------------------"); emps.stream() .sorted((x, y) -&gt; &#123; if(x.getAge() == y.getAge())&#123; return x.getName().compareTo(y.getName()); &#125;else&#123; return Integer.compare(x.getAge(), y.getAge()); &#125; &#125;).forEach(System.out::println);&#125; 终止操作（终端操作）一个终止操作，执行中间操作链，并产生结果 12345678910// 初始数据List&lt;Employee&gt; emps = Arrays.asList( new Employee(102, "李四", 79, 6666.66, Status.BUSY), new Employee(101, "张三", 18, 9999.99, Status.FREE), new Employee(103, "王五", 28, 3333.33, Status.VOCATION), new Employee(104, "赵六", 8, 7777.77, Status.BUSY), new Employee(104, "赵六", 8, 7777.77, Status.FREE), new Employee(104, "赵六", 8, 7777.77, Status.FREE), new Employee(105, "田七", 38, 5555.55, Status.BUSY)); ● 查找与匹配1) count：返回流中元素的总个数12long count = emps.stream().filter((e) -&gt; e.getStatus().equals(Status.FREE)).count();System.out.println(count); 2) max：返回流中最大值12Optional&lt;Double&gt; op = emps.stream().map(Employee::getSalary).max(Double::compare);System.out.println(op.get()); 3) min：返回流中最小值12Optional&lt;Employee&gt; op2 = emps.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));System.out.println(op2.get()); ● 归约可以将流中元素反复结合起来，得到一个值 1) reduce(T identity, BinaryOperator)12345678public void test1()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum = list.stream().reduce(0, (x, y) -&gt; x + y); System.out.println(sum); Optional&lt;Double&gt; op = emps.stream().map(Employee::getSalary).reduce(Double::sum); System.out.println(op.get());&#125; 2) reduce(BinaryOperator)123456789101112// 需求：搜索名字中 “六” 出现的次数public void test2()&#123; Optional&lt;Integer&gt; sum = emps.stream().map(Employee::getName) .flatMap(TestStreamAPI1::filterCharacter) .map((ch) -&gt; &#123; if(ch.equals('六')) return 1; else return 0; &#125;).reduce(Integer::sum); System.out.println(sum.get());&#125; ● 收集将流转换为其他形式，接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法 1) toList：List 把流中元素收集到List1List&lt;String&gt; list = emps.stream().map(Employee::getName).collect(Collectors.toList()); 2) toSet：Set 把流中元素收集到Set1Set&lt;String&gt; set = emps.stream().map(Employee::getName).collect(Collectors.toSet()); 3) toCollection：Collection 把流中元素收集到创建的集合1HashSet&lt;String&gt; hs = emps.stream().map(Employee::getName).collect(Collectors.toCollection(HashSet::new)); 4) counting：Long 计算流中元素的个数12//员工总数Long count = emps.stream().collect(Collectors.counting()); 5) averagingDouble：Double 计算流中元素Double属性的平均值12//工资平均值Double avg = emps.stream().collect(Collectors.averagingDouble(Employee::getSalary)); 6) summingDouble：Double 对流中元素的Double属性求和12//工资总和Double sum = emps.stream().collect(Collectors.summingDouble(Employee::getSalary)); 7) maxBy：Optional 根据比较器选择最大值123//最大工资员工Optional&lt;Employee&gt; max = emps.stream() .collect(Collectors.maxBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()))); 8) minBy：Optional 根据比较器选择最小值123//最小工资Optional&lt;Double&gt; min = emps.stream().map(Employee::getSalary) .collect(Collectors.minBy(Double::compare)); 9) summarizingDouble：DoubleSummaryStatistics 收集流中Double属性的统计值。如：平均值等1234567//收集统计类DoubleSummaryStatistics dss = emps.stream().collect(Collectors.summarizingDouble(Employee::getSalary));System.out.println(dss.getMax());System.out.println(dss.getAverage());System.out.println(dss.getMin());System.out.println(dss.getSum());System.out.println(dss.getCount()); 10) joining：String 连接流中每个字符串12//连接字符串String str = emps.stream().map(Employee::getName).collect(Collectors.joining("," , "----", "----")); 11) groupingBy：Map&lt;K,List&gt; 根据某属性值对流分组，属性为K，结果为V12//分组Map&lt;Status, List&lt;Employee&gt;&gt; map = emps.stream().collect(Collectors.groupingBy(Employee::getStatus)); 12345678910//多级分组Map&lt;Status, Map&lt;String, List&lt;Employee&gt;&gt;&gt; map = emps.stream() .collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy((e) -&gt; &#123; if(e.getAge() &gt;= 60) return "老年"; else if(e.getAge() &gt;= 35) return "中年"; else return "成年";&#125;))); 12) partitioningBy：Map&lt;Boolean,List&gt; 根据true或false进行分区123//分区Map&lt;Boolean, List&lt;Employee&gt;&gt; map = emps.stream() .collect(Collectors.partitioningBy((e) -&gt; e.getSalary() &gt;= 5000)); 总结Stream API肯定是不止上面介绍的这些，针对不同的数据类型这里只列出了一种，所以上面介绍的只是最常用的。]]></content>
      <categories>
        <category>JAVA8笔记</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JAVA8笔记】04、方法引用]]></title>
    <url>%2FJAVA8-004%2F</url>
    <content type="text"><![CDATA[若 Lambda 体中的功能，已经有方法提供了实现，可以使用方法引用（可以将方法引用理解为 Lambda 表达式的另外一种表现形式） 方法引用方法引用所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致 对象 : : 实例方法名ObjectName::MethodName 1234567891011public void test1()&#123; PrintStream ps = System.out; Consumer&lt;String&gt; con = (str) -&gt; ps.println(str); con.accept("Hello World！"); System.out.println("--------------------------------"); Consumer&lt;String&gt; con2 = ps::println; con2.accept("Hello Java8！"); System.out.println("--------------------------------"); Consumer&lt;String&gt; con3 = System.out::println; con3.accept("Hello Java8 Method!");&#125; 12345678public void test2()&#123; Employee emp = new Employee(101, "ZhangShan", 18, 9999.99); Supplier&lt;String&gt; sup = () -&gt; emp.getName(); System.out.println(sup.get()); System.out.println("----------------------------------"); Supplier&lt;String&gt; sup2 = emp::getName; System.out.println(sup2.get());&#125; 类 : : 静态方法名ClassName::StaticMethodName 12345public void test3()&#123; Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y); System.out.println("-----------------------------------"); Comparator&lt;Integer&gt; com2 = Integer::compare;&#125; 1234567public void test4()&#123; BiFunction&lt;Double, Double, Double&gt; fun = (x, y) -&gt; Math.max(x, y); System.out.println(fun.apply(1.5, 22.2)); System.out.println("--------------------------------------------"); BiFunction&lt;Double, Double, Double&gt; fun2 = Math::max; System.out.println(fun2.apply(1.2, 1.5));&#125; 类 : : 实例方法名若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，使用格式： ClassName::MethodName 12345678910111213public void test5()&#123; BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y); System.out.println(bp.test("abcde", "abcde")); System.out.println("-----------------------------------------"); BiPredicate&lt;String, String&gt; bp2 = String::equals; System.out.println(bp2.test("abc", "abc")); System.out.println("-----------------------------------------"); Function&lt;Employee, String&gt; fun = (e) -&gt; e.show(); System.out.println(fun.apply(new Employee())); System.out.println("-----------------------------------------"); Function&lt;Employee, String&gt; fun2 = Employee::show; System.out.println(fun2.apply(new Employee()));&#125; 构造器引用类 : : newClassName::new 1234567public void test6()&#123; Supplier&lt;Employee&gt; sup = () -&gt; new Employee(); System.out.println(sup.get()); System.out.println("------------------------------------"); Supplier&lt;Employee&gt; sup2 = Employee::new; System.out.println(sup2.get());&#125; 1234public void test7()&#123; Function&lt;String, Employee&gt; fun = Employee::new; BiFunction&lt;String, Integer, Employee&gt; fun2 = Employee::new;&#125; 数组引用类型[ ] : : newType[]::new 123456789public void test8()&#123; Function&lt;Integer, String[]&gt; fun = (args) -&gt; new String[args]; String[] strs = fun.apply(10); System.out.println(strs.length); System.out.println("--------------------------"); Function&lt;Integer, Employee[]&gt; fun2 = Employee[] :: new; Employee[] emps = fun2.apply(20); System.out.println(emps.length);&#125; 总结Lambda语法结合方法引用会使代码更加简洁]]></content>
      <categories>
        <category>JAVA8笔记</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JAVA8笔记】03、Lambda语法和函数式接口]]></title>
    <url>%2FJAVA8-003%2F</url>
    <content type="text"><![CDATA[Lambda中新增的操作符新的操作符Java8中引入了一个新的操作符 “-&gt;” ，该操作符称为箭头操作符或 Lambda 操作符 操作符结构箭头操作符将Lambda表达式拆分成两部分：○ 左侧：Lambda 表达式的参数列表○ 右侧：Lambda 表达式中所需执行的功能， 即 Lambda 体 Lambda表达式语法格式格式一：无参数，无返回值() -&gt; System.out.println(“Hello Lambda!”) 12345678910111213int num = 0; //jdk 1.7 must be finalRunnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println("Hello World!" + num); &#125;&#125;;r.run();System.out.println("-------------------------------");Runnable r1 = () -&gt; System.out.println("Hello Lambda!");r1.run(); 格式二：有一个参数，并且无返回值(x) -&gt; System.out.println(x) 12Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);con.accept("Hello Java8"); 格式三：若只有一个参数，小括号可以省略不写x -&gt; System.out.println(x) 12Consumer&lt;String&gt; con = x -&gt; System.out.println(x);con.accept("Hello Java8"); 格式四：有两个以上的参数，有返回值，并且 Lambda 体中有多条语句1234Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123; System.out.println("Functional Inteface"); return Integer.compare(x, y);&#125;; 格式五：若 Lambda 体中只有一条语句， return 和 大括号都可以省略不写1Comparator&lt;Integer&gt; com = (Integer x, Integer y) -&gt; Integer.compare(x, y); 格式六：Lambda 表达式的参数列表的数据类型可以省略不写因为JVM编译器通过上下文推断出数据类型，即“类型推断” 1(x, y) -&gt; Integer.compare(x, y); 格式总结上联：左右遇一括号省下联：左侧推断类型省横批：能省则省 函数式接口简介Lambda 表达式需要“函数式接口”的支持 定义接口中只有一个抽象方法的接口，称为函数式接口；可以使用注解 @FunctionalInterface 修饰，可以检查是否是函数式接口。 需求：对一个数进行运算1) 自定一个函数式接口1234@FunctionalInterfacepublic interface MyFun &#123; public Integer getValue(Integer num);&#125; 2) 核心的运算方法123public Integer operation(Integer num, MyFun mf)&#123; return mf.getValue(num);&#125; 3) 测试一下123456@Testpublic void test6()&#123; Integer num = operation(100, (x) -&gt; x * x); System.out.println(num); System.out.println(operation(200, (y) -&gt; y + 200));&#125; 核心函数式接口(1) Consumer : 消费型接口 —— void accept(T t); 需求：消费1W块钱 ● 业务逻辑 123public void happy(double money, Consumer&lt;Double&gt; con)&#123; con.accept(money);&#125; ● 测试方法 1234@Testpublic void test1()&#123; happy(10000, (m) -&gt; System.out.println("I happy cost：" + m + "Y"));&#125; (2) Supplier : 供给型接口 —— T get(); 需求：产生指定个数的整数，并放入集合中 ● 业务逻辑 12345678public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) &#123; Integer n = sup.get(); list.add(n); &#125; return list;&#125; ● 测试方法 1234567@Testpublic void test2()&#123; List&lt;Integer&gt; numList = getNumList(10, () -&gt; (int)(Math.random() * 100)); for (Integer num : numList) &#123; System.out.println(num); &#125;&#125; (3) Function&lt;T, R&gt; : 函数型接口 —— R apply(T t); 需求：用于处理字符串 ● 业务逻辑 123public String strHandler(String str, Function&lt;String, String&gt; fun)&#123; return fun.apply(str);&#125; ● 测试方法 1234567@Testpublic void test3()&#123; String newStr = strHandler("\t\t\t My Baby YZ ", (str) -&gt; str.trim()); System.out.println(newStr); String subStr = strHandler("My Baby FF", (str) -&gt; str.substring(2, 5)); System.out.println(subStr);&#125; (4) Predicate : 断言型接口 —— boolean test(T t); 需求：将满足条件的字符串，放入集合中 ● 业务逻辑 123456789public List&lt;String&gt; filterStr(List&lt;String&gt; list, Predicate&lt;String&gt; pre)&#123; List&lt;String&gt; strList = new ArrayList&lt;&gt;(); for (String str : list) &#123; if(pre.test(str))&#123; strList.add(str); &#125; &#125; return strList;&#125; ● 测试方法 1234567public void test4()&#123; List&lt;String&gt; list = Arrays.asList("Hello", "atguigu", "Lambda", "www", "ok"); List&lt;String&gt; strList = filterStr(list, (s) -&gt; s.length() &gt; 3); for (String str : strList) &#123; System.out.println(str); &#125;&#125; 总结Lambda表达式与函数式接口是亲兄弟]]></content>
      <categories>
        <category>JAVA8笔记</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SpringCloud笔记】10、Bus - 消息总线]]></title>
    <url>%2FSpringCloud-010%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Spring Cloud Config Version：2.0.0.RELEASE Spring Cloud Bus Version：2.0.0.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在上一篇的文章中已经介绍了分布式配置中心的使用，并且在文章末尾提到了如果我们想要实现服务配置修改后自动刷新所有的集群客户端需要用到Spring Cloud Bus这一组件。 Spring Cloud Bus 将分布式系统的节点通过轻量级消息代理连接起来。用于在集群中传播状态更改（例如配置更改事件）或其他管理指令。Spring Cloud Bus 的一个核心思想是通过分布式的启动器对 Spring Boot 应用进行扩展，也可以用来建立一个或多个应用之间的通信频道。目前唯一实现的方式是用 AMQP 消息代理作为通道。 消息总线消息总线是一种通信工具，可以在机器之间互相传输消息、文件等。消息总线扮演着一种消息路由的角色，拥有一套完备的路由机制来决定消息传输方向。发送段只需要向消息总线发出消息而不用管消息被如何转发。 Spring cloud bus 通过轻量消息代理连接各个分布的节点。管理和传播所有分布式项目中的消息，本质是利用了MQ的广播机制在分布式的系统中传播消息，目前常用的有Kafka和RabbitMQ。 消息代理消息代理（Message Broker）是一种消息验证、传输、路由的架构模式。消息代理是一个中间件产品，它的核心是一个消息的路由程序，用来实现接收和分发消息，并根据设定好的消息处理流来转发给正确的应用。它包括独立的通信和消息传递协议，能够实现组织内部和组织间的网络通信。设计代理的目的就是为了能够从应用程序中传入消息，并执行一些特别的操作。现有的消息代理开源产品：ActiveMQ、Kafka、RabbitMQ、RocketMQ。目前Spring Cloud Bus 支持 RabbitMQ（spring-cloud-starter-bus-amqp） 和 Kafka（spring-cloud-starter-bus-kafka），本文将以RabbitMQ为例。 修改config-servert工程加入Bus组件1. 修改pom文件加入bus组件依赖 12345 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; 2. 修改application.yml配置文件 1234567891011121314151617181920212223242526272829303132 server: port: 8000spring: application: name: config-server cloud: config: label: master server: git: uri: https://github.com/rocye/SpringcloudConfig/ searchPaths: springcloudstudy# username: ***# password: *** rabbitmq: host: 176.10.10.233 port: 5672 username: guest password: guesteureka: client: service-url: defaultZone: http://localhost:8761/eureka/#新版本新的配置方法: /actuator/bus-refreshmanagement: endpoints: web: exposure: include: ["bus-refresh"] 修改itest-config工程加入Bus组件1. 修改pom文件加入bus组件依赖 12345 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; 2. 修改application.yml配置文件 1234567891011121314151617 server: port: 8001spring: application: name: itest-config rabbitmq: host: 176.10.10.233 port: 5672 username: guest password: guesteureka: client: service-url: defaultZone: http://localhost:8761/eureka/ RabbitMQ的安装 本文测试所用到消息队列是RabbitMQ，至于RabbitMQ的安装，这里将略过，不作详述，网上有很多相关的教程。 启动项目进行测试 (1) Step：先后启动itest-server，config-servert，itest-config:8001，itest-config:8002四个工程后打开: http://localhost:8761 可以看到如下页面 (2) Setp：接下来可以打开: http://176.10.10.233:15672/#/exchanges 查看RabbitMQ控制台，此时已经自动创建了一个名为springCloudBus的exchange，这正是由上面添加的Bus组件所创建的 (3) Setp：再次打开浏览器输入: http://localhost:8001/msg 或 http://localhost:8002/msg 可以看到如下页面 (4) Step：重新修改Git仓库中的application-dev.yml配置文件并Push到远程仓库 1msg: this is dev config modify 2018.07.13-01 (5) Setp：打开浏览器输入: http://localhost:8000/springcloudstudy/dev 可以看到如下页面 (6) Step：这里只需要用Postman使用Post方法请求 http://localhost:8000/actuator/bus-refresh 而不再需要给每个需要更新配置的客户端发送 /actuator/refresh 可以看到 itest-config:8001 和 itest-config:8002 两个实例的日志输出表示已经自动请求配置服务器更新本地配置信息 (7) Step：再次刷新上面的地址：http://localhost:8001/msg 或 http://localhost:8002/msg ，可以看到通过上面紧紧一次的Bus刷新，所有的客户端配置已经自动更新了 (8) Step：同时我们可以打开: http://176.10.10.233:15672/#/queues 查看RabbitMQ控制台，已经有多个以springCloudBus开头的队列了，集群数量越多这里的队列也相应增多 源码下载：https://github.com/rocye/SpringCloudStudy 总结在上一篇文章中的最后我们提到自动刷新，虽然加入了消息总线(Bus)之后，我们只需要手动刷新一次就可以让所有的集群客户端自动更新配置。但是仍然不是自动刷新，所以还需要用到Git的webhooks来达到自动更新配置。 打开git上配置仓库的地址，添加webhooks，上面的Payload URL就填写我们的配置中心触发刷新的地址，肯定是需要外网能访问地址才行，这里就不详述，有兴趣可以自行尝试一下。具体操作可参考文末的博客地址。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_bushttps://www.w3cschool.cn/spring_cloud/spring_cloud-jl8a2ixp.htmlhttps://blog.csdn.net/forezp/article/details/70148235https://ask.csdn.net/questions/684472https://blog.csdn.net/u010416588/article/details/54599341]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Bus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JAVA8笔记】02、为什么使用Lambda表达式]]></title>
    <url>%2FJAVA8-002%2F</url>
    <content type="text"><![CDATA[Lambda是一种匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。 原来的匿名内部类1234567Comparator&lt;Integer&gt; com = new Comparator&lt;Integer&gt;()&#123; @Override public int compare(Integer o1, Integer o2) &#123; return Integer.compare(o1, o2); &#125;&#125;;TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;(com); 现在的Lambda表达式12Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;(com); 具体业务需求分析1、基础数据○ 定义员工类123456public class Employee &#123; private int id; private String name; private int age; private double salary;&#125; ○ 定义初始值1234567List&lt;Employee&gt; emps = Arrays.asList( new Employee(101, "张三", 18, 9999.99), new Employee(102, "李四", 59, 6666.66), new Employee(103, "王五", 28, 3333.33), new Employee(104, "赵六", 8, 7777.77), new Employee(105, "田七", 38, 5555.55)); 2、具体需求最原始的做法，来一个需求就要写一个过滤方法，代码冗余 ○ 需求1：获取公司中年龄小于35的员工信息123456789public List&lt;Employee&gt; filterEmployeeAge(List&lt;Employee&gt; emps)&#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); for (Employee emp : emps) &#123; if(emp.getAge() &lt;= 35)&#123; list.add(emp); &#125; &#125; return list;&#125; 123456public void test3()&#123; List&lt;Employee&gt; list = filterEmployeeAge(emps); for (Employee employee : list) &#123; System.out.println(employee); &#125;&#125; ○ 需求2：获取公司中工资大于 5000 的员工信息123456789public List&lt;Employee&gt; filterEmployeeSalary(List&lt;Employee&gt; emps)&#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); for (Employee emp : emps) &#123; if(emp.getSalary() &gt;= 5000)&#123; list.add(emp); &#125; &#125; return list;&#125; 123456public void test4()&#123; List&lt;Employee&gt; list = filterEmployeeSalary(emps); for (Employee employee : list) &#123; System.out.println(employee); &#125;&#125; 3、优化方式一：策略设计模式只需一个过滤方法，不用写冗余代码，有新需求只需要添加新的策略实现类 即可，在JAVA7中算是最优的设计模式优化方法；缺点是每次都要创建一个策略实现类。(1) 创建策略接口或抽象类：123public interface MyPredicate&lt;T&gt; &#123; public boolean test(T t);&#125; (2) 只需一个过滤方法：123456789public List&lt;Employee&gt; filterEmployee(List&lt;Employee&gt; emps, MyPredicate&lt;Employee&gt; mp)&#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); for (Employee employee : emps) &#123; if(mp.test(employee))&#123; list.add(employee); &#125; &#125; return list;&#125; (3) 需求1 的策略实现类：123456public class FilterEmployeeForAge implements MyPredicate&lt;Employee&gt;&#123; @Override public boolean test(Employee t) &#123; return t.getAge() &lt;= 35; &#125;&#125; (4) 需求2 的策略实现类：123456public class FilterEmployeeForSalary implements MyPredicate&lt;Employee&gt; &#123; @Override public boolean test(Employee t) &#123; return t.getSalary() &gt;= 5000; &#125;&#125; (5) 测试一下如何调用：1234567891011121314@Testpublic void test4()&#123; List&lt;Employee&gt; list = filterEmployee(emps, new FilterEmployeeForAge()); for (Employee employee : list) &#123; System.out.println(employee); &#125; System.out.println("------------------------------------------"); List&lt;Employee&gt; list2 = filterEmployee(emps, new FilterEmployeeForSalary()); for (Employee employee : list2) &#123; System.out.println(employee); &#125;&#125; 4、优化方式二：匿名内部类在策略模式优化方法的基础上用匿名内部类的方式减少类文件的创建。123456789101112@Testpublic void test5()&#123; List&lt;Employee&gt; list = filterEmployee(emps, new MyPredicate&lt;Employee&gt;() &#123; @Override public boolean test(Employee t) &#123; return t.getId() &lt;= 103; &#125; &#125;); for (Employee employee : list) &#123; System.out.println(employee); &#125;&#125; 5、优化方式三：Lambda表达式在策略模式优化方法的基础上用Lambda表达式简化匿名内部类多余的代码。12345678910@Testpublic void test6()&#123; List&lt;Employee&gt; list = filterEmployee(emps, (e) -&gt; e.getAge() &lt;= 35); list.forEach(System.out::println); System.out.println("------------------------------------------"); List&lt;Employee&gt; list2 = filterEmployee(emps, (e) -&gt; e.getSalary() &gt;= 5000); list2.forEach(System.out::println);&#125; 6、优化方式四：Stream API假定在没有前面任何优化方法前提下，直接用Stream解决。123456@Testpublic void test7()&#123; emps.stream().filter((e) -&gt; e.getAge() &lt;= 35).forEach(System.out::println); System.out.println("----------------------------------------------"); emps.stream().map(Employee::getName).limit(3).sorted().forEach(System.out::println);&#125; 总结Lambda表达式有没有相当简洁。]]></content>
      <categories>
        <category>JAVA8笔记</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SpringCloud笔记】09、SpringCloudConfig - 分布式配置中心]]></title>
    <url>%2FSpringCloud-009%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Spring Cloud Config Version：2.0.0.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在分布式系统中，由于服务数量巨大，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件Spring Cloud Config，它支持配置数据放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在Spring Cloud Config组件中，分两个角色：Config Server和Config Client，业界也有些知名的同类开源产品，比如百度的Disconf。 相比同类产品Spring Cloud Config最大的优势是和Spring无缝集成，支持Spring里面Environment和PropertySource的接口，对于已有的Spring应用程序的迁移成本非常低，在配置获取的接口上是完全一致，结合SpringBoot可使你的项目有更加统一的标准（包括依赖版本和约束规范），避免了应为集成不同开软件源造成的依赖版本冲突。 创建服务端配置远程Git仓库在本地创建服务端配置文件的仓库并上传到Github，其中包括三个配置文件：application-dev.yml、application-pro.yml及application-test.yml，具体的Github地址：https://github.com/rocye/SpringCloudConfig/tree/master/springcloudstudy 具体内容如下： 创建Config Server工程1. 在父工程的基础上创建一个Module子工程用作Config Server (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery及Config Server依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011121314151617181920server: port: 8000spring: application: name: config-server cloud: config: label: master server: git: uri: https://github.com/rocye/SpringcloudConfig/ searchPaths: springcloudstudy# username: ***# password: ***eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ PS：本文使用的是公共仓库不需要用户名和密码，如果是私有仓库需要配置用户名和密码。 3. 修改相关代码并启动测试 (1) Step：在启动类上加入注解@EnableEurekaClient和@EnableConfigServer (2) Step：先后启动itest-server和config-server两个工程后打开测试页面： 测试地址：http://localhost:8000/springcloudstudy/dev 测试地址：http://localhost:8000/springcloudstudy/pro 测试地址：http://localhost:8000/springcloudstudy/test 由此可见，Config Server工程已创建成功，已经可以远程获取配置信息了。 Http请求地址和资源文件映射如下：/{application}/{profile}[/{label}]/{application}-{profile}.yml/{label}/{application}-{profile}.yml/{application}-{profile}.properties/{label}/{application}-{profile}.properties 关于application.yml与bootstrap.ymlSpringBoot默认支持properties和YAML两种格式的配置文件。前者格式简单，但是只支持键值对。如果需要表达列表，最好使用YAML格式。SpringBoot支持自动加载约定名称的配置文件，例如application.yml。如果是自定义名称的配置文件，就要另找方法了。可惜的是，不像前者有@PropertySource这样方便的加载方式，后者的加载必须借助编码逻辑来实现。 1.加载顺序 bootstrap.yml：用于程序引导时执行，应用于更加早期配置信息读取，用来配置application.yml中使用到参数等。 application.yml：应用程序特有配置信息，可以用来配置后续各个模块中需使用的公共参数等。 bootstrap.yml 先于 application.yml 加载，bootstrap.yml 由父Spring ApplicationContext加载。 2.配置区别 bootstrap.yml和application.yml 都可以用来配置参数。 bootstrap.yml 可以理解成系统级别的一些参数配置，这些参数一般是不会变动的。 application.yml 可以用来定义应用级别的，如搭配 spring-cloud-config 使用 application.yml 里面定义的文件可以实现动态替换。 使用Spring Cloud Config Server时，应在 bootstrap.yml 中指定常用信息： spring.application.name spring.cloud.config.server.git.uri 一些加密/解密信息 相关文章：SpringCloud配置文件 application.yml和 bootstrap.yml区别Spring Boot中application.yml与bootstrap.yml的区别 创建Config Client工程1. 在父工程的基础上创建一个Module子工程用作Config Client (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery、Web及Config Client依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011server: port: 8001spring: application: name: itest-configeureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 增加bootstrap.yml配置文件并加入如下配置 123456spring: cloud: config: uri: http://localhost:8000/ label: master profile: dev 3. 修改相关代码并启动测试 (1) Step：在启动类上加入注解@EnableEurekaClient和@RestController并加入测试接口 (2) Step：先后启动itest-server，config-server，itest-config 三个工程后打开测试页面 测试地址：http://localhost:8001/msg (3) Step：修改bootstrap.yml中的profile为test后再次刷新上面的测试页面可以看到对应的信息 123456spring: cloud: config: uri: http://localhost:8000/ label: master profile: test (4) Step：修改本地application.yml加入msg测试本地配置覆盖远程配置 (5) Step：还需要修改远程配置（以application-test.yml为例）加入allowOverride: true（记得修改完要Push到Git远程仓库中） PS：默认情况下，本地的配置文件不能覆盖远程配置，但是可以通过启动命令行参数来覆盖远程配置。如果需要本地文件覆盖远程文件，需要在远程配置文件里设置授权spring.cloud.config.allowOverride=true（这个配置不能在本地被设置）。一旦设置了这个权限，你可以配置更加细粒度的配置来配置覆盖的方式，比如： ● spring.cloud.config.overrideNone=true 覆盖任何本地属性 ● spring.cloud.config.overrideSystemProperties=false 仅仅系统属性和环境变量 (6) Step：重启itest-config工程再次刷新上面的测试页面可以看到本地配置已覆盖远程配置 配置手动刷新项目一旦放到生产环境，就需要不停机更改配置。比如更改一些线程池连接数什么的，或者是配置文件，这里测试手动刷新Git仓库上的配置文件。 1. 修改itest-config相关代码 (1) Step：在项目pom文件中加入actuator依赖，就可以使用/refresh 这个节点来刷新带有@RefreshScope注解服务的Bean (2) Step：在启动类上加入注解@RefreshScope (3) Step：修改Git仓库中的application-dev.yml配置文件并Push到远程仓库 1msg: this is dev config modify 2018.07.10-01 (4) Step：手动刷新需要通过使用post方法去请求 http://localhost:8001/refresh 来调用refresh方法 但是返回404，说明此接口已请求不到，其原因主要还是SpringCloud版本的问题，在最新的版本中指出由于endpoints中会包含很多敏感信息，提示需要小心的暴露它们，这也是management.security.enabled=false被删除的原因。具体接口列表可查看此官方链接：Endpoints ，会发现除了health和info两个支持web访问外，其他的默认不支持web访问。 (5) Step：解决方法是在bootstrap.yml文件中添加下面的代码：management.endpoints.web.exposure.include=* 暴露全部endpoints，我们这里只暴露 refresh 接口 1234567891011121314151617 spring: cloud: config:# uri: http://localhost:8000/ label: master profile: dev discovery: enabled: true service-id: config-server#新版本新的配置方法: /actuator/refreshmanagement: endpoints: web: exposure: include: ["refresh"] 2. 重启itest-config进行测试 (1) Step：重新启动itest-config工程，再用Postman使用post方法请求 http://localhost:8001/actuator/refresh (2) Step：发送Post请求成功后，会发现控制台会打印类似重启的信息 (3) Step：重新修改Git仓库中的application-dev.yml配置文件并Push到远程仓库 1msg: this is dev config modify 2018.07.10-02 (4) Step：再用Postman使用Post方法请求 /actuator/refresh 打开上面的测试地址：http://localhost:8001/msg ，可以看到手动刷新已生效 高可用分布式配置中心在实际的生产环境中往往会有非常多的服务实例，都需要从配置中心读取文件，所以很有必要将配置中心进行集群化，从而达到高可用。 1. 改造itest-config工程 修改配置文件bootstrap.yml，加入集群配置相关信息： 12345678910 spring: cloud: config:# uri: http://localhost:8000/ label: master profile: dev discovery: enabled: true service-id: config-server 2. 重新启动工程进行测试 重新启动config-server:8000，config-server:8800，itest-config三个工程，其中包括config-server两个实例，打开：http://localhost:8761/ 可以看到如下页面 重新访问 http://localhost:8001/msg 可以看到如下页面，说明高可用的配置已经生效 源码下载：https://github.com/rocye/SpringCloudStudy 总结SpringCloudConfig就是我们通常意义上的配置中心，把应用原本放在本地文件的配置抽取出来放在中心服务器，从而能够提供更好的管理、发布能力。SpringCloudConfig分服务端和客户端，服务端负责将git svn中存储的配置文件发布成REST接口，客户端可以从服务端REST接口获取配置。但客户端并不能主动感知到配置的变化，从而主动去获取新的配置，这需要每个客户端通过POST方法触发各自的/refresh。手动刷新在实际的生产环境中仍然是很繁琐的，这时就需要用到另一个组件Bus了。 SpringCloudBus通过一个轻量级消息代理连接分布式系统的节点。这可以用于广播状态更改（如配置更改）或其他管理指令。SpringCloudBus提供了通过POST方法访问的endpoint/bus/refresh，这个接口通常由git的钩子功能调用，用以通知各个SpringCloudConfig的客户端去服务端更新配置。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_confighttps://www.w3cschool.cn/spring_cloud/spring_cloud-vca32ixm.htmlhttps://blog.csdn.net/forezp/article/details/70037291https://www.cnblogs.com/BlogNetSpace/p/8469033.htmlhttps://blog.csdn.net/jeikerxiao/article/details/78914132https://zhuanlan.zhihu.com/p/34784934https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>SpringCloudConfig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JAVA8笔记】01、JAVA8新特性简介]]></title>
    <url>%2FJAVA8-001%2F</url>
    <content type="text"><![CDATA[速度更快我们应该知道JAVA8中最为核心是Lambda表达式和Stream API，除此之外JAVA8还在底层数据结构及内存结构等方面做了优化，目的都是为了让它速度更快。 ● 底层数据结构进行了优化- HashMap（HashSet同理）1) 在JAVA7中 HashMap = 数组 + 链表 ：不管我们将hashCode与equals方法写的多好，都有可能发生碰撞，碰撞是指hashCode相同但是key却不相同，些时会放在链表中。 2) 在JAVA8中 HashMap = 数组 + 链表 + 红黑树 ：通过加入红黑树优化后，除了添加操作外，其它的查找，删除，修改等效率都大大提升。即：当碰撞元素个数大于8并且总容量大于64时将会使链表转成红黑树。 相关文章：Java8系列之重新认识HashMapJava7/Java8中HashMap解析 - ConcurrentHashMap1) 在JAVA7中采用分段锁机制(默认16个段) ：JAVA7中通过并行级别参数（ConcurrentLevel=16）进行分段锁机制，提高并行效率。 2) 在JAVA8中不再采用锁机制而是改成CAS算法 相关文章：Java8—ConcurrentHashMap分析ConcurrentHashMap演进从Java7到Java8 ● 内存结构及垃圾回收机制进行了优化- JAVA7内存结构调优配置参数：PremGenSize 和 MaxPremGenSize - JAVA8内存结构调优配置参数：MetaSpaceSize 和 MaxMetaSpaceSize PS：使用了物理内存后垃圾回收机制效率都将得到提升，且OOM异常发生的概率也极低，因为项目的类结构文件占不了太大的空间。 相关文章：JAVA7、JAVA8的堆内存有啥变化Java8—底层内存结构方法区 ● 能更好的支持并行运算即并行流ParallelStream 代码更少增加了新的语法Lambda表达式 Stream API增加了强大的Stream API 便于并行增加了并行流ParallelStream 最大化减少空指针异常增加了Optional 相关文章：Java 8 Optional类深度解析使用 Java 8 Optional 的正确姿势 总结以上只是JAVA8新特性的简介。 PS：JAVA8新特性中最为核心的是Lambda表达式与Stream API]]></content>
      <categories>
        <category>JAVA8笔记</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SpringCloud笔记】08、Zuul - 路由网关]]></title>
    <url>%2FSpringCloud-008%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Zuul Version：2.0.0.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在前面的文章中我们已经介绍了好几个微服务架构中最基础的服务治理组件，包括服务注册与发现(Eureka)、服务消费及负载均衡(Ribbon&amp;Feign)和断路器(Hystrix&amp;Turbine)，接下来我们还会介绍路由网关及服务配置等。由于此系列笔记都是分开测试的各个组件，很难体会到各组件整体的概念，如果初学者有类似这样的模糊不清感觉，大家可以再回过头去看下此系列第一篇文章：从微服务框架到SpringCloud ，在这篇文章找到微服务化要点关联图，相信会对组件之间的关联有一个更深的理解。 Zuul简介Zuul是Netflix的基于JVM的路由器和服务器端负载均衡器，在云平台上提供动态路由，监控，弹性，安全等边缘服务的框架。路由功能：相当于 nginx 的反向代理功能，比如：/ 可能需要映射到你的 web 应用，/api/users 映射到用户服务，/api/shop 映射到商城服务。Zuul默认和Ribbon结合实现了负载均衡的功能。所包含的功能： Authentication：认证 Insights：洞察 Stress Testing：压力测试 Canary Testing：金丝雀测试 Dynamic Routing：动态路由 Service Migration：服务迁移 Load Shedding：负载脱落 Security：安全 Static Response handling：静态响应处理 Active/Active traffic management：主动/主动流量管理 创建Zuul服务网关1. 在父工程的基础上创建一个Module子工程用作Zuul服务网关 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery,Web及Zuul依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011121314151617181920server: port: 8766spring: application: name: itest-zuuleureka: client: service-url: defaultZone: http://localhost:8761/eureka/zuul: routes: api-a: path: /api-a/** serviceId: itest-ribbon api-b: path: /api-b/** serviceId: itest-feign 3. 修改相关代码并启动测试 (1) Step：在启动类上加入注解@EnableEurekaClient和@EnableZuulProxy (2) Step：先后启动itest-server，itest-client，itest-ribbon, itest-order，itest-feign, itest-zuul 六个工程后打开: http://localhost:8761 可以看到如下页面 (3) Step：打开浏览器输入: http://localhost:8766/api-a/testRibbon?name=rocye 可以看到如下页面 (4) Setp：打开浏览器输入: http://localhost:8766/api-b/testFeign?name=fruit 可以看到如下页面 由此可见，Zuul的路由功能已经生效了。 自定义过滤器Zuul 不仅只是路由，可以自定义过滤器来实现服务验证。测试：自定义过滤器，校验头部是否带有 token，如果 token=MyToken 通过校验， 若不存在或者不为 MyToken 则返回提示 tonken 错误。 √ 在工程中加入自定义过滤器 1234567891011121314151617181920212223242526272829303132333435363738394041424344import com.netflix.zuul.ZuulFilter;import com.netflix.zuul.context.RequestContext;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import org.springframework.util.ReflectionUtils;import javax.servlet.http.HttpServletRequest;@Componentpublic class MyPreFilter extends ZuulFilter &#123; private static Logger logger = LoggerFactory.getLogger(MyPreFilter.class); public String filterType() &#123; return "pre"; &#125; public int filterOrder() &#123; return 0; &#125; public boolean shouldFilter() &#123; return true; &#125; public Object run() &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); logger.warn(String.format("%s &gt;&gt;&gt; %s", request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter("token"); if(!"MyToken".equals(accessToken))&#123; ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); try &#123; ctx.getResponse().getWriter().write("token is empty or error !"); &#125; catch (Exception e) &#123; ReflectionUtils.rethrowRuntimeException(e); &#125; logger.warn("token error !"); &#125;else&#123; logger.warn("token success !"); &#125; return null; &#125;&#125; √ 自定义过滤器中的filterType类型 filterType：返回一个字符串代表过滤器的类型，在Zuul中定义了四种不同生命周期的过滤器类型，具体如下： pre：路由之前 routing：路由之时 post： 路由之后 error：发送错误调用 filterOrder：过滤的顺序。 shouldFilter：这里可以写逻辑判断，是否要过滤，本文true，永远过滤。 run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。 过滤器的生命周期： √ 重新启动itest-zuul工程测试 (1) Step：再次打开地址: http://localhost:8766/api-a/testRibbon?name=rocye 可以看到如下页面 因为没有带token所以提示错误，修改地址打开: http://localhost:8766/api-a/testRibbon?name=rocye&amp;token=MyToken 可以看到正确的结果 (2) Setp：再次打开地址: http://localhost:8766/api-b/testFeign?name=fruit 可以看到如下页面 同样提示错误，同样修改地址打开: http://localhost:8766/api-b/testFeign?name=fruit&amp;token=MyToken 也可以看到正确的结果 由此可见，自定义过滤器已经达到了预期的效果。 源码下载：https://github.com/rocye/SpringCloudStudy 总结路由网关Zuul组件所包含的内容及相关配置远不止本文所介绍的这些，本系列文章旨在入门，让初学者先有一个概念，先了解它的核心，以后的文章会慢慢进行深入探讨。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#_router_and_filter_zuulhttps://blog.csdn.net/dengqiang123456/article/details/76223526https://blog.csdn.net/dengqiang123456/article/details/76223537https://blog.csdn.net/forezp/article/details/69939114https://www.cnblogs.com/lexiaofei/p/7080257.htmlhttps://www.w3cschool.cn/spring_cloud/spring_cloud-pzs12ixk.html]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SpringCloud笔记】07、Turbine - 断路器集群监控]]></title>
    <url>%2FSpringCloud-007%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Turbine Version：2.0.0.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在前面两篇文章中介绍了Hystrix监控单体应用，但是在生产环境中，我们要监控的应用往往是一个集群。而且在复杂的分布式系统中，相同服务的节点经常需要部署上百甚至上千个，很多时候，运维人员希望能够把相同服务的节点状态以一个整体集群的形式展现出来，这样可以更好的把握整个系统的状态。 为此，Netflix提供了一个开源项目（Turbine）来提供把多个hystrix.stream的内容聚合为一个数据源供Dashboard展示。 监控单个集群应用(默认名称)cluster-name-expression: new String(‘default’)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认集群名称 1. 在父工程的基础上创建一个Module子工程用作Turbine监控客户端 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery,Hystrix Dashboard及Turbine依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 123456789101112131415161718server: port: 9000spring: application: name: itest-turbineeureka: client: service-url: defaultZone: http://localhost:8761/eureka/turbine: app-config: itest-ribbon cluster-name-expression: new String('default')# aggregator:# cluster-config: default combine-host-port: true 配置说明：turbine.app-config：# 配置Eureka中的serviceId，这里表示只监测itest-ribbon这一个应用（或对应的集群）turbine.aggregator.cluster-config：# 指定聚合哪些集群，多个使用”,”分割，默认为defaultturbine.clusterNameExpression：# default表示默认集群名，当值为default时上面的cluster-config可以省略turbine.combine-host-port：# true表示同一主机上的服务通过host和port的组合来进行区分，默认情况下是使用host来区分的 3. 修改相关代码 在启动类上加入注解@EnableTurbine和@EnableHystrixDashboard用于开启Turbine及仪表盘功能 4. 启动项目进行测试 (1) Step：先后启动itest-server，itest-client，itest-ribbon:8764, itest-ribbon:8774, itest-turbine五个工程后打开: http://localhost:8761 可以看到如下页面 (2) Setp：但是控制台可能会出现如下异常 123456com.netflix.turbine.monitor.instance.InstanceMonitor$MisconfiguredHostException:[&#123;"timestamp":"2018-06-28T08:01:38.908+0000","status":404,"error":"Not Found","message":"No message available","path":"/actuator/hystrix.stream"&#125;]at com.netflix.turbine.monitor.instance.InstanceMonitor.init(InstanceMonitor.java:318) ~[turbine-core-1.0.0.jar:na]at com.netflix.turbine.monitor.instance.InstanceMonitor.access$100(InstanceMonitor.java:103) ~[turbine-core-1.0.0.jar:na]at com.netflix.turbine.monitor.instance.InstanceMonitor$2.call(InstanceMonitor.java:235) [turbine-core-1.0.0.jar:na]at com.netflix.turbine.monitor.instance.InstanceMonitor$2.call(InstanceMonitor.java:229) [turbine-core-1.0.0.jar:na] 原因是因为Turbine启动后无法找到 “/actuator/hystrix.stream” ，在前面文章 Hystrix - 断路器之在Ribbon中的使用 中我们所配置的路径是”/hystrix.stream”，所以这里会导致上面的 404 异常，解决办法是需要加入配置如下 (3) Setp：重启itest-turbine工程一切正常，打开 http://localhost:9000/hystrix 然后输入监控地址，因为前面我们使用的是default cluster所以这里输入：http://localhost:9000/turbine.stream (4) Setp：点击 Monitor Stream 按钮后，需要访问 http://localhost:8764/testRibbon?name=rocye 和 http://localhost:8774/testRibbon?name=rocye 可以多刷新几次，可以看到如下效果 从仪表盘页面显示可以看到 Hosts 为 2 表示集群数量，以上就是Turbine监控单个集群在仪表盘中的显示效果 5. 仪表盘上参数详细说明 在前面的文章中大概介绍过仪表盘上的参数，但不是很全，这里再补上一张更详细的注解图 监控多个集群应用(默认名称) cluster-name-expression: new String(‘default’)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认集群名称 1. 在父工程的基础上创建一个Module子工程用作另一个微服务测试应用 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery及Web依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011server: port: 8763spring: application: name: itest-ordereureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 3. 修改相关代码 (1) Step：在启动类上加入注解@EnableEurekaClient (2) Step：创建OrderController类，对外提供服务 (3) Step：修改前面的工程itest-feign，让它调用itest-order提供的服务 123456789101112import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Service;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;@Service("feignService")@FeignClient(value = "itest-order",fallback = FeignServiceHystrix.class)public interface IFeignService &#123; @RequestMapping(value = "/order", method = RequestMethod.GET) String testFeign(@RequestParam(value = "name") String name);&#125; (4) Step：修改工程itest-turbine中的turbine配置加入新的集群itest-feign 1234567891011121314151617181920 server: port: 9000spring: application: name: itest-turbineeureka: client: service-url: defaultZone: http://localhost:8761/eureka/turbine: app-config: itest-ribbon,itest-feign cluster-name-expression: new String('default')# aggregator:# cluster-config: default combine-host-port: true instanceUrlSuffix: /hystrix.stream 4. 启动项目进行测试 (1) Step：先后启动itest-server, itest-client, itest-order, itest-ribbon:8764, itest-ribbon:8774, itest-feign:8765, itest-feign:8775, itest-turbine 八个工程后打开: http://localhost:8761 可以看到如下页面，其中itest-ribbon和itest-feign分别启动两个实例模拟两个集群服务 (2) Setp：重新打开 http://localhost:9000/hystrix 然后依然输入前面那个默认集群名(defalut)所用到的监控地址：http://localhost:9000/turbine.stream 点击 Monitor Stream 按钮后，需要访问下面四个地址，可以多刷新几次： http://localhost:8764/testRibbon?name=rocye ， http://localhost:8774/testRibbon?name=rocye http://localhost:8765/testFeign?name=fruit ， http://localhost:8775/testFeign?name=fruit 就能看到仪表盘中参数的变化，如下图中的效果 监控单个集群应用(指定名称) cluster-name-expression: new String(‘APPNAME’)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;监控单集群时可以省略 1. 修改itest-turbine工程的配置 这里修改为只监控itest-ribbon一个集群，集群名通过应用名指定 1234567891011121314151617181920server: port: 9000spring: application: name: itest-turbineeureka: client: service-url: defaultZone: http://localhost:8761/eureka/turbine: app-config: itest-ribbon# cluster-name-expression: new String('ITEST-RIBBON') aggregator: cluster-config: ITEST-RIBBON combine-host-port: true instanceUrlSuffix: /hystrix.stream 2. 启动项目进行测试 (1) Step：先后启动itest-server, itest-client, itest-ribbon:8764, itest-ribbon:8774, itest-turbine 五个工程后打开: http://localhost:8761 可以看到如下页面 (2) Setp：重新打开 http://localhost:9000/hystrix 然后输入新的监控地址：http://localhost:9000/turbine.stream?cluster=ITEST-RIBBON (3) Setp：点击 Monitor Stream 按钮后，需要访问 http://localhost:8764/testRibbon?name=rocye 和 http://localhost:8774/testRibbon?name=rocye 可以多刷新几次，就能看到如下效果 从结果可以看出此配置方式和上面的默认名称下的单个集群应用配置效果一样 监控多个集群应用(指定名称) cluster-name-expression: metadata[‘cluster’]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自定义集群名称 1. 修改工程配置文件 (1) Step：修改itest-turbine配置文件自定义集群名称监控多个集群应用 1234567891011121314151617181920server: port: 9000spring: application: name: itest-turbineeureka: client: service-url: defaultZone: http://localhost:8761/eureka/turbine: app-config: itest-ribbon,itest-feign cluster-name-expression: metadata['cluster'] aggregator: cluster-config: mycluster combine-host-port: true instanceUrlSuffix: /hystrix.stream (2) Step：修改itest-ribbon配置文件指定cluster 123456789101112131415server: port: 8764spring: application: name: itest-ribboneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: metadata-map: cluster: mycluster (3) Step：修改itest-feign配置文件指定cluster 12345678910111213141516171819server: port: 8765spring: application: name: itest-feigneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: metadata-map: cluster: myclusterfeign: hystrix: enabled: true 2. 启动项目进行测试 (1) Step：先后启动itest-server, itest-client, itest-order, itest-ribbon:8764, itest-ribbon:8774, itest-feign:8765, itest-feign:8775, itest-turbine 八个工程后打开: http://localhost:8761 可以看到如下页面，其中itest-ribbon和itest-feign分别启动两个实例模拟两个集群服务 (2) Setp：重新打开 http://localhost:9000/hystrix 然后输入新的监控地址：http://localhost:9000/turbine.stream?cluster=mycluster 点击 Monitor Stream 按钮后，需要访问下面四个地址，可以多刷新几次： http://localhost:8764/testRibbon?name=rocye ， http://localhost:8774/testRibbon?name=rocye http://localhost:8765/testFeign?name=fruit ， http://localhost:8775/testFeign?name=fruit 就能看到仪表盘中参数的变化，如下图中的效果 源码下载：https://github.com/rocye/SpringCloudStudy 总结本文是根据cluster-name-expression参数的不同值进行了详细测试，主要是因为在网上找到的一些博客只是对参数进行了说明，没有代码示例，仍然觉得云里雾里，所以干脆把这几种情况都测试了一下，篇服较大，图片较多，但是根据最终的效果应该能清楚区分此参数不同值之间的区别。 参考文章：https://blog.csdn.net/u012702547/article/details/78224483http://www.ityouknow.com/springcloud/2017/05/18/hystrix-dashboard-turbine.htmlhttps://blog.csdn.net/dengqiang123456/article/details/76223521https://blog.csdn.net/forezp/article/details/70233227]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Hystrix</tag>
        <tag>Turbine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SpringCloud笔记】06、Hystrix - 断路器之在Feign中的使用]]></title>
    <url>%2FSpringCloud-006%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Feign Version：2.0.0.RELEASE Hystrix Version：1.4.4.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在上一篇的文章中已经介绍了Hystrix在Ribbon中的使用，我们知道Ribbon和Feign所完成的功能都是服务消费，本篇文章将会介绍Hystrix断路器在Feign中的使用。 修改itest-feign工程加入断路器1. 不需要修改pom文件 如果只是开启Feign的断路器功能不需要在pom文件中额外加入hystrix依赖 2. 修改相关代码 (1) Step：添加断路器回调方法，实现先前接口IFeignService新建回调类：FeignServiceHystrix (2) Step：然后修改接口IFeignService指定回调类 (3) Step：最后还需要修改application.yml开启断路器功能 3. 启动项目进行测试 (1) Step：先后启动itest-server，itest-client，itest-feign三个工程后打开: http://localhost:8761 可以看到如下页面 (2) Setp：打开浏览器输入: http://localhost:8765/testFeign?name=rocye 可以看到如下页面 (3) Setp：接下来关闭itest-client工程，查看断路器是否生效（需要等几秒刷新上面的页面） 由此可见，断路器已经生效了。 4. 加入Hystrix Dashboard (断路器仪表盘) (1) Step：在pom文件中加入hystrix dashboard依赖 12345678910111213141516&lt;!-- 2.加入断路器仪表盘功能 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; (2) Setp：在启动类上加入注解@EnableHystrixDashboard用于开启断路器仪表盘功能，同时加入hystrix.stream的Servlet (3) Setp：重启itest-feign工程，打开: http://localhost:8765/hystrix 页面 (4) Setp：然后输入监测地址：http://localhost:8765/hystrix.stream 点击“Moniter Stream”，接下来可以在浏览器中打开: http://localhost:8765/testFeign?name=rocye 多刷新几次可以看到监测的效果如下所示 源码下载：https://github.com/rocye/SpringCloudStudy 总结Feign底层整合了Ribbon，两者相比较而言，声明式的Feign用起来更方便。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clientshttps://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_dashboardhttps://blog.csdn.net/forezp/article/details/69934399https://blog.csdn.net/yejingtao703/article/details/77683102]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Feign</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SpringCloud笔记】05、Hystrix - 断路器之在Ribbon中的使用]]></title>
    <url>%2FSpringCloud-005%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Ribbon Version：2.0.0.RELEASE Hystrix Version：1.4.4.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud中可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是常说的“雪崩”效应。为了解决这个问题，业界提出了断路器模型。 断路器简介Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：较底层的服务如果出现故障，会导致连锁故障。当对特定服务的调用不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。 修改itest-ribbon工程加入断路器1. 修改工程pom.xml文件 在pom文件中加入hystrix依赖 123456&lt;!-- 2.加入断路器功能 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; 2. 修改相关代码 (1) Step：在启动类上加入注解@EnableHystrixet用于开启断路器功能 (2) Step：然后在测试类TestService对应的接口方法加入注解@HystrixCommand 定义断路器回调方法 123public String testError(String name) &#123; return "hello " + name + ", happen error!";&#125; 3. 启动项目进行测试 (1) Step：先后启动itest-server，itest-client，itest-ribbon三个工程后打开: http://localhost:8761 可以看到如下页面 (2) Setp：打开浏览器输入: http://localhost:8764/testRibbon?name=rocye 可以看到如下页面 (3) Setp：接下来关闭itest-client工程，查看断路器是否生效（需要等几秒刷新上面的页面） 由此可见，断路器已经生效了。 4. 加入Hystrix Dashboard (断路器仪表盘) (1) Step：在pom文件中加入hystrix dashboard依赖 1234567891011&lt;!-- 3.加入断路器仪表盘功能 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; PS：手动修改POM文件后，如果发现依赖没生效，可以Reimport解决，如下所示 刷新完后看到最终的依赖如下所示 (2) Setp：在启动类上加入注解@EnableHystrixDashboard用于开启断路器仪表盘功能 (3) Setp：重启itest-ribbon工程，打开: http://localhost:8764/hystrix 页面 然后输入监测地址：http://localhost:8764/hystrix.stream 点击“Moniter Stream” 但是无法正常显示数据而是显示：Unable to connect to Command Metric Stream. 查看日志发现报 404 错误，是因为hystrix.stream地址找不到 (4) Setp：解决办法是需要加入hystrix.stream的Servlet 12345678910//断路器仪表盘功能(解决hystrix.stream : 404 : HTTP/1.1 404 )@Beanpublic ServletRegistrationBean getServlet()&#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings("/hystrix.stream"); registrationBean.setName("HystrixMetricsStreamServlet"); return registrationBean;&#125; (5) Setp：然后重启itest-ribbon工程，再次打开: http://localhost:8764/hystrix 页面输入: http://localhost:8764/hystrix.stream 点击按钮就不再报上面的错了，接下来可以在浏览器中打开: http://localhost:8764/testRibbon?name=rocye 多刷新几次可以看到监测的效果如下所示 PS：实心圆：颜色代表健康度（绿-黄-红-橙递减），大小代表并发量；曲线：请求量的变化；其他主要参数如下图红色字体部分： 源码下载：https://github.com/rocye/SpringCloudStudy 总结以上是单结点服务的统计，相对简单，但是生产上为了服务的健壮性都是多结点，当被监控的服务变成了多个，在Dashboard之前需要一个收集器Turbine，此组件以后再专门介绍。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clientshttps://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_dashboardhttps://blog.csdn.net/forezp/article/details/69934399https://blog.csdn.net/yejingtao703/article/details/77683102]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Ribbon</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SpringCloud笔记】04、Feign - 声明式REST客户端]]></title>
    <url>%2FSpringCloud-004%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在上一篇文章中，我们介绍了通过RestTemplate和Ribbon的服务调用及负载均衡的使用，在Spring Cloud中服务之间通过restful方式调用除了前面介绍的Ribbon外还有一种即是本篇要介绍的Feign。 Feign简介Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。 创建Feign客户端1. 在父工程的基础上创建一个Module子工程用作Ribbon负载均衡器 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery,Web及Feign依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011server: port: 8765spring: application: name: itest-feigneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 3. 修改相关代码 (1) Step：在启动类上加入注解@EnableEurekaClient和@EnableFeignClients (2) Step：创建feign接口，通过@FeignClient(“服务名”)，来指定调用哪个服务及具体的接口 (3) Step：创建TestController类用于调用IFeignService进行测试 注：这里注入IFeignService接口时可能会在某些IDE中报语法错，可以在上面的接口中加入@Service注解解决些问题 4. 启动项目进行测试 (1) Step：先启动Eureka服务端itest-server，然后修改启动配置，先启动itest-client端口8762，再启动itest-client端口8763 打开: http://localhost:8761 可以看到itest-client两个实例 (2) Setp：最后启动Feign客户端，刷新上面的页面可以看到itest-feign实例 最终我们启动了如下四个实例 (3) Setp：打开浏览器输入: http://localhost:8765/testFeign?name=rocye 多刷新几次页面可以看到8762和8763端口交替出现 由此可见，已经达到了负载均衡的效果。 源码下载：https://github.com/rocye/SpringCloudStudy 总结 服务注册中心：itest-server 端口为8761 两个测试用的服务实例：itest-client 端口为8762和8763，都注册到了Eureka服务端 服务消费实例(即负载均衡器)：itest-feign端口为8765，也注册到了Eureka服务端 从实践上看，采用feign的方式更优雅，而且feign内部也使用了ribbon做负载均衡 参考文章：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-feignhttps://blog.csdn.net/forezp/article/details/69808079https://blog.csdn.net/jrn1012/article/details/77837658]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SpringCloud笔记】03、Ribbon - 客户端负载均衡器]]></title>
    <url>%2FSpringCloud-003%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在上一篇文章中，我们介绍了使用Eureka作为服务注册中心，在服务启动后，各个微服务会将自己注册到Eureka server。那么服务之间是如何调用？又是如何进行负载均衡的？本文将介绍服务的调用及负载均衡器Ribbon的使用。 创建Ribbon负载均衡器1. 在父工程的基础上创建一个Module子工程用作Ribbon负载均衡器 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery,Web及Ribbon依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011server: port: 8764spring: application: name: itest-ribboneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 3. 修改相关代码 (1) Step：在启动类上加入注解@EnableEurekaClient，再通过@Bean注入restTemplate，并通过@LoadBalanced开启负载均衡 (2) Step：创建测试类TestService并注入restTemplate，用来调用itest-client服务的”/test”接口 (3) Step：创建TestController类用于调用TestService进行测试 4. 启动项目进行测试 (1) Step：先启动Eureka服务端itest-server，然后修改启动配置，先启动itest-client端口8762，再启动itest-client端口8763 打开: http://localhost:8761 可以看到itest-client两个实例 (2) Setp：最后启动ribbon负载均衡器，刷新上面的页面可以看到itest-ribbon实例 最终我们启动了如下四个实例 (3) Setp：打开浏览器输入: http://localhost:8764/testRibbon?name=rocye 多刷新几次页面可以看到8762和8763端口交替出现 由此可见，已经达到了负载均衡的效果。 源码下载：https://github.com/rocye/SpringCloudStudy 总结 服务注册中心：itest-server 端口为8761 两个测试用的服务实例：itest-client 端口为8762和8763，都注册到了Eureka服务端 服务消费实例(即负载均衡器)：itest-ribbon 端口为8764，也注册到了Eureka服务端 Ribbon是对服务之间调用做负载，是服务之间的负载均衡，Zuul是可以对外部请求做负载均衡 PS：Zuul的负载均衡功能是针对外部请求做负载。客户端ribbon的负载均衡，解决的是服务发起方（在Eureka注册的服务）对被调用的服务的负载，比如我们查询商品服务要调用显示库存和商品明细服务，通过商品服务的接口将两个服务组合，可以减少外部应用的请求。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-ribbonhttps://blog.csdn.net/forezp/article/details/69788938https://blog.csdn.net/jrn1012/article/details/77837658]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SpringCloud笔记】02、Eureka - 服务的注册与发现]]></title>
    <url>%2FSpringCloud-002%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Sping Boot Version：2.0.3.RELEASE 创建Eureka服务器 (eureka server)1. 创建一个Maven主工程 (1) Step：这里不勾选“Create from archetype” (2) Step：自定义GroupId和ArtifactId (3) Step：自定义工程名及路径 (4) Step：创建完成后如下图，因为是空的父工程所以可以将src文件夹删除 2. 在父工程的基础上创建一个Module子工程用作Eureka服务器 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里只需要选择Eureka服务端依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 3. 修改工程配置文件类型为YML并加入配置 (1) Step：修改application.properties为application.yml（注：本工程配置文件将全部采用YML格式） (2) Step：在配置文件中加入如下配置，其中将registerWithEureka和fetchRegistry设置为false标识此为服务端 1234567891011server: port: 8761eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 4. 在启动类上加入注解@EnableEurekaServer 启动itest-server工程，在浏览器中打开：http://localhost:8761 看到下图所示页面表示Eureka服务端已创建成功 创建Eureka客户端 (eureka client)1. 在父工程的基础上创建一个Module子工程用作Eureka客户端 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery和Web依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置，其中service-url(或serviceUrl)配置成服务端地址 1234567891011server: port: 8762spring: application: name: itest-clienteureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 3. 在启动类上加入注解@EnableEurekaClient 4. 依次启动itest-server和itest-client工程，打开：http://localhost:8761 看到下图所示页面表示Eureka节点已创建成功 PS：测试Eureka节点关闭被服务端踢出需要正常退出，不能强制关闭，如下图 5. 创建测试的RestController(上面加入的Web依赖在这里用到) 6. 重启itest-client工程，在浏览器中打开：http://localhost:8762/test?name=rocye 看到下图所示页面 源码下载：https://github.com/rocye/SpringCloudStudy 总结基于IntelliJ IDEA开发工具构建Spring Cloud工程非常简单和方便，合理利用配置步骤中的选择来生成配置文件能减少不必要的错误。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-eureka-serverhttps://springcloud.cc/spring-cloud-dalston.html#_service_discovery_eureka_clientshttps://blog.csdn.net/forezp/article/details/69696915]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SpringCloud笔记】01、从微服务框架到SpringCloud]]></title>
    <url>%2FSpringCloud-001%2F</url>
    <content type="text"><![CDATA[什么是微服务框架对于微服务基础框架可以看作是微服务治理架构的核心内容，包括了对微服务模块的全生命周期管理能力，这个能力包括了微服务网关APP，DevOps，Docker和云集成，安全，负载均衡，服务注册和发现等诸多能力。微服务基础框架确实不是简单的微服务网关，而是对整个微服务基础环境的支撑和管控。 Netflix的微服务框架Netflix是一家成功实践微服务架构的互联网公司，几年前，Netflix把几乎整个微服务框架栈开源贡献给了社区，这些框架和组件包括： Eureka：服务注册发现框架 Zuul：服务网关 Karyon：服务端框架 Ribbon：客户端框架 Hystrix：服务容错组件 Archaius：服务配置组件 Servo：Metrics组件 Blitz4j：日志组件 下图展示了基于这些组件构建的一个微服务框架体系： Netflix的开源框架组件已经在Netflix的大规模分布式微服务环境中经过多年的生产实战验证，正逐步被社区接受为构造微服务框架的标准组件。Pivotal去年推出的Spring Cloud开源产品，主要是基于对Netflix开源组件的进一步封装，方便Spring开发人员构建微服务基础框架。 微服务化要点关联图了解了Netflix的微服务框架核心组件之后，我们很有必要总览一下这些组件之间的关系，这样更有利于对整个微服务框架的理解，接下来借用网易云的一张架构图，就能很清晰的了解这些组件之间的关系了： Spring CloudSpring Cloud正是对Netflix的多个开源组件进一步的封装而成，同时又实现了和云端平台及Spring Boot开发框架很好的集成。Spring Cloud 为开发者提供了在分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，一次性token，全局锁，leader选举，分布式session，集群状态等等）中快速构建的工具，使用Spring Cloud的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。 Spring Cloud Netflix，该项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路有（Zuul），客户端负载均衡（Ribbon）等。 当然Spring Cloud还有额外扩展的其它很多组件，包括了服务链路监控和跟踪（很关键的一个功能），消息总线，数据流处理，批量任务处理等。而对于整个Spring Cloud微服务框架简单来说，即是：你只要划分到你的微服务组件和模块，并定义好需要暴露的API接口，那么剩下的整个开发和传统方式没有太大的区别，你开发完成的组件集成起来就是一个分布式可扩展的微服务环境。里面设计到的接口发布，服务注册，服务调用和路由，服务监控，健康检测和流控等都会由微服务框架来帮你完成。 PS：正是有了成熟的微服务框架，我们才更应该将微服务架构设计重心从技术底层转移到组件划分和接口设计上。 Spring Cloud VS DubboR1：背景Dubbo：是阿里巴巴服务化治理的核心框架，并被广泛应用于阿里巴巴集团的各成员站点。 Spring Cloud：是Spring Source的产物，Spring社区的强大背书可以说是Java企业界最有影响力的组织了，除了Spring Source之外，还有Pivotal和Netfix是其强大的后盾与技术输出。其中Netflix开源的整套微服务架构套件是Spring Cloud的核心。 R2：社区活跃度我们选择一个开源框架，社区的活跃度是我们极为关注的一个要点。社区越活跃，解决问题的速度越快，框架也会越来越完善，不然当我们碰到问题，就不得不自己解决。而对于团队来说，也就意味着我们不得不自己去维护框架的源码，这对于团队来说也将会是一个很大的负担。 Dubbo ：https://github.com/dubbo Spring Cloud ：https://github.com/spring-cloud 小结：在社区活跃度上，Spring Cloud毋庸置疑的优于Dubbo，这对于没有大量精力与财力维护这部分开源内容的团队来说，Spring Cloud会是更优的选择。 R3：架构完整度根据微服务架构在各方面的要素，看看Spring Cloud和Dubbo都提供了哪些支持： Dubbo Spring Cloud 服务注册中心 Zookeeper Spring Cloud Netflix Eureka 服务调用方式 RPC REST API 服务网关 无 Spring Cloud Netflix Zuul 断路器 不完善 Spring Cloud Netflix Hystrix 分布式配置 无 Spring Cloud Config 服务跟踪 无 Spring Cloud Sleuth 消息总线 无 Spring Cloud Bus 数据流 无 Spring Cloud Stream 批量任务 无 Spring Cloud Task …… …… …… Dubbo对于上表中总结为“无”的组件不代表不能实现，而只是Dubbo框架自身不提供，需要另外整合以实现对应的功能，比如： 分布式配置：可以使用淘宝的diamond、百度的disconf来实现分布式配置管理。但是Spring Cloud中的Config组件除了提供配置管理之外，由于其存储可以使用git，因此它天然的实现了配置内容的版本管理，可以完美的与应用版本管理整合起来。服务跟踪：可以使用京东开源的Hydra批量任务：可以使用当当开源的Elastic-Job…… R4：对比总结通过上面几个环节上的分析，打个不恰当的比喻：使用Dubbo构建的微服务架构就像组装电脑，各环节我们的选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果你是一名高手，那这些都不是问题；而Spring Cloud就像品牌机，在Spring Source的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性，但是如果要在使用非原装组件外的东西，就需要对其基础有足够的了解。 参考文章：http://blog.sina.com.cn/s/blog_493a84550102wkna.htmlhttp://blog.sina.com.cn/s/blog_493a84550102wkp2.htmlhttp://blog.didispace.com/microservice-framework/]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务框架</tag>
      </tags>
  </entry>
</search>
